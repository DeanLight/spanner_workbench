# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/020_semantic_checks.ipynb.

# %% auto 0
__all__ = ['serialize_tree', 'remove_new_lines_from_strings', 'check_referenced_vars_exist', 'rules_to_dataclasses',
           'consistent_free_var_types_in_rule', 'is_rule_safe', 'execute_statement']

# %% ../nbs/020_semantic_checks.ipynb 3
from abc import ABC, abstractmethod
import pytest

# from lark import Transformer, Token
# from lark import Tree as LarkNode
# from lark.visitors import Interpreter, Visitor_Recursive, Visitor
from pathlib import Path
from typing import no_type_check, Set, Sequence, Any,Optional,List,Callable,Dict,Union
from pydantic import BaseModel
import networkx as nx

# from spannerlib.ast_node_types import (Assignment, ReadAssignment, AddFact, RemoveFact, Query, Rule, IERelation, RelationDeclaration, Relation)
from .primitive_types import Span, DataTypes, DataTypeMapping
# from spannerlib.engine import RESERVED_RELATION_PREFIX
# # from spannerlib.graphs import NetxStateGraph
# from spannerlib.symbol_table import SymbolTableBase
# from spannerlib.general_utils import (get_free_var_names, get_output_free_var_names, get_input_free_var_names, fixed_point, check_properly_typed_relation, type_check_rule_free_vars)
# from spannerlib.passes_utils import assert_expected_node_structure, unravel_lark_node,ParseNodeType

from graph_rewrite import draw, draw_match, rewrite, rewrite_iter

from .grammar import parse_spannerlog
from .span import Span
from spannerlib.engine import (
    Engine,
    Var,
    FreeVar,
    RelationDefinition,
    Relation,
    IEFunction,
    IERelation,
    Rule,
    pretty,
    )

# %% ../nbs/020_semantic_checks.ipynb 5
def serialize_tree(g):
    root = next(nx.topological_sort(g))
    return nx.tree_data(g,root) 


# %% ../nbs/020_semantic_checks.ipynb 14
def remove_new_lines_from_strings(ast,engine):
    for match in rewrite_iter(ast,
        lhs='v[type="string",val]'):
        # TODO we also remove the starting and ending quotes, TODO make them disapear in the parsing stage
        match['v']['val'] = match['v']['val'].replace('\\\n','')[1:-1]


# %% ../nbs/020_semantic_checks.ipynb 24
def check_referenced_vars_exist(ast,engine):

    # first rename all left hand sign variables 
    # as type "var_name_lhs"
    # so we can seperate them from reference variables
    for assignment_type in ["assignment","read_assignment"]:
        for match in rewrite_iter(ast,
                lhs=f"""X[type="{assignment_type}"]-[idx=0]->LHS[type="var_name",val]"""
                ):
            match['LHS']['type'] = "var_name_lhs"

    # now for each reference variable check if it is in the symbol table
    for match in rewrite_iter(ast,lhs=f"""X[type="var_name",val]"""):
        var_name = match['X']['val'].name
        if not engine.get_var(var_name):
            raise ValueError(f'Variable {var_name} is not defined')


# %% ../nbs/020_semantic_checks.ipynb 34
def rules_to_dataclasses(ast,engine):
   for match in rewrite_iter(ast,
      lhs='''
         statement[type="rule"]->head[type="rule_head",val];
         statement->body[type="rule_body_relation_list"]
      ''',p='statement[type]'):
      body_nodes = list(ast.successors(match.mapping['body']))
      head = match['head']['val']
      match['statement']['val'] = Rule(head=match['head']['val'],body=[ast.nodes[body_node]['val'] for body_node in body_nodes])
      ast.remove_nodes_from(body_nodes)
   return ast

# %% ../nbs/020_semantic_checks.ipynb 37
def _check_rule_consistency(rule,engine):
    # for each free var we encounter, what is the type is is according to the relation schema
    free_var_to_type = {}
    # what is the first relation we found each var in, useful for error messages
    first_rel_to_define_free_var = {}

    # go over each body relation
    for rel_idx,relation in enumerate(rule.body):

        # if ie relation split into two relations
        rel_type_terms_and_schema_list = []
        if isinstance(relation,Relation):
            rel_type_terms_and_schema_list.append(('relation',relation.terms,engine.get_relation(relation.name).scheme))
        elif isinstance(relation,IERelation):
            rel_type_terms_and_schema_list.append(('ie input relation',relation.in_terms,engine.get_ie_function(relation.name).in_schema))
            rel_type_terms_and_schema_list.append(('ie output relation',relation.out_terms,engine.get_ie_function(relation.name).out_schema))

        # for each relation type in the body relation
        for rel_type_terms_and_schema in rel_type_terms_and_schema_list:
            rel_type,terms,expected_schema = rel_type_terms_and_schema
            # for each term in the relation that is a free var
            for term_idx,(term,expected_type) in enumerate(zip(terms,expected_schema)):
                if isinstance(term,FreeVar):
                    # check if was defined before in other body relations
                    # if so must have same type as before
                    if term.name in free_var_to_type:
                        if free_var_to_type[term.name] != expected_type:
                            predefined_relation,predefined_term_idx = first_rel_to_define_free_var[term.name]
                            raise ValueError(f"In rule {pretty(rule)}, in body {rel_type} {pretty(relation)}, FreeVar {term.name} position {term_idx} expects type {pretty(expected_type)} "
                                            f"but was previously defined in relation {pretty(predefined_relation)} position {predefined_term_idx} with type {pretty(free_var_to_type[term.name])}")
                    # if not register it to the mapping
                    else:
                        free_var_to_type[term.name] = expected_type
                        first_rel_to_define_free_var[term.name] = (relation.name,term_idx)

    # for rule head, make sure all free vars are defined in the body
    # and if the rule head was used in another rule, make sure it has the same types
    head_name, head_terms = rule.head.name, rule.head.terms

    current_head_schema = []
    for term in head_terms:
        if not isinstance(term,FreeVar):
            raise ValueError(f"In rule {pretty(rule)}, in head clause {head_name}, only FreeVars are allowed")
        if not term.name in free_var_to_type:
            raise ValueError(f"In rule {pretty(rule)}, FreeVar {term.name} is used in the head but was not defined in the body")

    current_head_schema = RelationDefinition(name=head_name,scheme=[free_var_to_type[term.name] for term in head_terms])

    if engine.get_relation(head_name):
        expected_head_schema = engine.get_relation(head_name)
        if expected_head_schema != current_head_schema:
            raise ValueError(f"In rule {pretty(rule)}, expected schema {pretty(expected_head_schema)} from a previously defined rule to {head_name} but got {pretty(current_head_schema)}")

def consistent_free_var_types_in_rule(ast,engine):
    for match in rewrite_iter(ast,lhs='X[type="rule",val]'):
        rule = match['X']['val']
        _check_rule_consistency(rule,engine)
    return ast

# %% ../nbs/020_semantic_checks.ipynb 40
def is_rule_safe(rule:Rule):
    """
    Checks that the Spannerlog Rule is safe
    ---
    In spannerlog, rule safety is a semantic property that ensures that IE relation's inputs are limited 
    in the values they can be assigned to by other relations in the rule body.
    This could include outputs of other IE relations.

    We call a free variable in a rule body "bound" if it exists in the output of any safe relation in the rule body.
    For normal relations, they only have output terms, so all their free variables are considered bound.

    We call a relation in a rule's body safe if all its input free variables are bound.
    For normal relations, they don't have input relations, so they are always considered safe.

    We call a rule safe if all of its body relations are safe.

    This basically means that we need to make sure there is at least one order of IE relation evaluation, in which
    each IE relation input variables is bound by the normal relations and the output relation of the previous IE relations.

    Examples:
    * `rel2(X,Y) <- rel1(X,Z), ie1(X)->(Y)` is a safe rule as the only input free variable, `X`, exists in the output of the safe relation `rel1(X, Z)`.  
    * `rel2(Y) <- ie1(Z)->(Y)` is not safe as the input free variable `Z` does not exist in the output of any safe relation.
    * `rel2(Z,W) <- rel1(X,Y),ie1(Z,Y)->(W),ie2(W,Y)->Z` is not safe as both ie functions require each other's output as input, creating a circular dependency.
    ---
    """

    # get all free vars in regular relations
    normal_relations_free_vars = set()
    for body in rule.body:
        if isinstance(body,Relation):
            for term in body.terms:
                if isinstance(term,FreeVar):
                    normal_relations_free_vars.add(term.name)
    
    # get list of form [(ie_rel,{input_vars},{output_vars})]
    free_vars_per_ie_relation = {}
    for body in rule.body:
        if isinstance(body,IERelation):
            input_vars = set(term.name for term in body.in_terms if isinstance(term,FreeVar))
            output_vars = set(term.name for term in body.out_terms if isinstance(term,FreeVar))
            free_vars_per_ie_relation[body]=(input_vars,output_vars)
        
    # iteratively go over all previously unsafe ie relations and check if they are now safe

    safe_vars = normal_relations_free_vars.copy()
    safe_ie_relations = set()

    while True:
        if len(free_vars_per_ie_relation)==0:
            break
        
        safe_ie_relations_in_this_iteration = set()
        for ie_relation,(input_vars,output_vars) in free_vars_per_ie_relation.items():
            if input_vars.issubset(safe_vars):
                safe_ie_relations_in_this_iteration.add(ie_relation)
        
        if len(safe_ie_relations_in_this_iteration)== 0 :
            raise ValueError(f"Rule \'{pretty(rule)}\' is not safe:\n"
                            f"the following free vars where bound by normal relations: {normal_relations_free_vars}\n"
                            f"the following ie relations where safe: {safe_ie_relations}\n"
                            f"leading to the following free vars being bound: {safe_vars}\n"
                            f"However the following ie relations could not be bound: {[pretty(ie) for ie in free_vars_per_ie_relation.keys()]}\n"
                             )
    
        for ie_relation in safe_ie_relations_in_this_iteration:
            input_vars,output_vars = free_vars_per_ie_relation[ie_relation]
            safe_vars.update(output_vars)
            safe_ie_relations.add(ie_relation)
            del free_vars_per_ie_relation[ie_relation]



    return True

# %% ../nbs/020_semantic_checks.ipynb 47
def execute_statement(ast,engine):
    statement_node = list(ast.nodes)[0]
    node_data = ast.nodes[statement_node]
    statement = node_data['type']
    value = node_data['val']
    match statement:
        case 'assignment':
            engine.set_var(*value)
        case 'read_assignment':
            engine.set_var(*value,read_from_file=True)
        case 'add_fact':
            engine.add_fact(value)
        case 'remove_fact':
            engine.del_fact(value)
        case 'relation_declaration':
            engine.set_relation(value)
        case 'rule':
            return engine.add_rule(value)
        case 'query':
            return engine.run_query(value)
        case _:
            raise ValueError(f"Unknown statement type {statement}")

    
