# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/020_semantic_checks.ipynb.

# %% auto 0
__all__ = ['PrimitiveType', 'Type', 'Span', 'Var', 'FreeVar', 'RelationDefinition', 'Relation', 'IEFunction', 'IERelation',
           'Rule', 'pretty', 'remove_new_lines_from_strings', 'check_referenced_vars_exist', 'rules_to_dataclasses',
           'consistent_free_var_types_in_rule', 'is_rule_safe', 'add_to_symbol_table', 'assign_vars_to_symbol_table',
           'CheckReferencedRelationsExistenceAndArity', 'CheckReferencedIERelationsExistenceAndArity',
           'CheckRuleSafety', 'TypeCheckAssignments', 'TypeCheckRelations', 'SaveDeclaredRelationsSchemas',
           'ResolveVariablesReferences', 'ExecuteAssignments', 'AddStatementsToNetxParseGraph']

# %% ../nbs/020_semantic_checks.ipynb 3
from abc import ABC, abstractmethod
import pytest

# from lark import Transformer, Token
# from lark import Tree as LarkNode
# from lark.visitors import Interpreter, Visitor_Recursive, Visitor
from pathlib import Path
from typing import no_type_check, Set, Sequence, Any,Optional,List,Callable,Dict,Union
from pydantic import BaseModel
import networkx as nx

# from spannerlib.ast_node_types import (Assignment, ReadAssignment, AddFact, RemoveFact, Query, Rule, IERelation, RelationDeclaration, Relation)
from .primitive_types import Span, DataTypes, DataTypeMapping
# from spannerlib.engine import RESERVED_RELATION_PREFIX
# # from spannerlib.graphs import NetxStateGraph
# from spannerlib.symbol_table import SymbolTableBase
# from spannerlib.general_utils import (get_free_var_names, get_output_free_var_names, get_input_free_var_names, fixed_point, check_properly_typed_relation, type_check_rule_free_vars)
# from spannerlib.passes_utils import assert_expected_node_structure, unravel_lark_node,ParseNodeType

from graph_rewrite import draw, draw_match, rewrite, rewrite_iter

from .grammar import parse_spannerlog

# %% ../nbs/020_semantic_checks.ipynb 10
from enum import Enum
from typing import Any
from pydantic import ConfigDict

class Span(BaseModel):
    start: int
    end: int

    def __lt__(self, other: Span) -> bool:
        if self.start == other.start:
            return self.end < other.end

        return self.start < other.start

    # # used for sorting `Span`s in dataframes
    # def __hash__(self) -> int:
    #     return hash((self.start, self.end))

class Var(BaseModel):
    name: str
    def __hash__(self):
        return hash(self.name)

class FreeVar(BaseModel):
    name: str
    def __hash__(self):
        return hash(self.name)

PrimitiveType=Union[str,int,Span]
Type = Union[PrimitiveType,Var,FreeVar]

class RelationDefinition(BaseModel):
    model_config = ConfigDict(arbitrary_types_allowed=True)
    name: str
    scheme: List[type]

class Relation(BaseModel):
    model_config = ConfigDict(arbitrary_types_allowed=True)
    name: str
    terms: List[Type]

class IEFunction(BaseModel):
    model_config = ConfigDict(arbitrary_types_allowed=True)
    name: str
    in_schema: List[type]
    out_schema: List[type]
    func: Callable


class IERelation(BaseModel):
    model_config = ConfigDict(arbitrary_types_allowed=True)
    name: str
    in_terms: List[Type]
    out_terms: List[Type]
    def __hash__(self):
        hash_str = f'''{self.name}_in_{'_'.join([str(x) for x in self.in_terms])}_out_{'_'.join([str(x) for x in self.out_terms])}'''
        return hash(hash_str)
class Rule(BaseModel):
    model_config = ConfigDict(arbitrary_types_allowed=True)
    head: Relation
    body: List[Union[Relation,IERelation]]

# %% ../nbs/020_semantic_checks.ipynb 11
def pretty(obj):
    """pretty printing dataclasses for user messages,
    making them look like spannerlog code instead of python code"""
    
    if isinstance(obj,Span):
        return f"[{obj.start},{obj.end})"
    elif isinstance(obj,(Var,FreeVar)):
        return obj.name
    elif isinstance(obj,RelationDefinition):
        return f"{obj.name}({','.join(pretty(o) for o in obj.scheme)})"
    elif isinstance(obj,Relation):
        return f"{obj.name}({','.join(pretty(o) for o in obj.terms)})"
    elif isinstance(obj,IERelation):
        return f"{obj.name}({','.join(pretty(o) for o in obj.in_terms)}) -> ({','.join(pretty(o) for o in obj.out_terms)})"
    elif isinstance(obj,IEFunction):
        return f"{obj.name}({','.join(pretty(o) for o in obj.in_schema)}) -> ({','.join(pretty(o) for o in obj.out_schema)})"
    elif isinstance(obj,Rule):
        return f"{pretty(obj.head)} <- {','.join(pretty(o) for o in obj.body)}"
    elif isinstance(obj,type):
        return obj.__name__
    else:
        return str(obj)

# %% ../nbs/020_semantic_checks.ipynb 20
def remove_new_lines_from_strings(ast,sess):
    for match in rewrite_iter(ast,
        lhs='v[type="string",val]'):
        # TODO we also remove the starting and ending quotes, TODO make them disapear in the parsing stage
        match['v']['val'] = match['v']['val'].replace('\\\n','')[1:-1]


# %% ../nbs/020_semantic_checks.ipynb 30
def check_referenced_vars_exist(ast,sess):

    # first rename all left hand sign variables 
    # as type "var_name_lhs"
    # so we can seperate them from reference variables
    for assignment_type in ["assignment","read_assignment"]:
        for match in rewrite_iter(ast,
                lhs=f"""X[type="{assignment_type}"]-[idx=0]->LHS[type="var_name",val]"""
                ):
            match['LHS']['type'] = "var_name_lhs"

    # now for each reference variable check if it is in the symbol table
    for match in rewrite_iter(ast,lhs=f"""X[type="var_name",val]"""):
        var_name = match['X']['val'].name
        if not var_name in sess.symbol_table:
            raise ValueError(f'Variable {var_name} is not defined')


# %% ../nbs/020_semantic_checks.ipynb 40
def rules_to_dataclasses(ast,sess):
   for match in rewrite_iter(ast,
      lhs='''
         statement[type="rule"]->head[type="rule_head",val];
         statement->body[type="rule_body_relation_list"]
      ''',p='statement[type]'):
      body_nodes = list(ast.successors(match.mapping['body']))
      head = match['head']['val']
      match['statement']['val'] = Rule(head=match['head']['val'],body=[ast.nodes[body_node]['val'] for body_node in body_nodes])
      ast.remove_nodes_from(body_nodes)
   return ast

# %% ../nbs/020_semantic_checks.ipynb 43
def _check_rule_consistency(rule,sess):
    # for each free var we encounter, what is the type is is according to the relation schema
    free_var_to_type = {}
    # what is the first relation we found each var in, useful for error messages
    first_rel_to_define_free_var = {}

    # go over each body relation
    for rel_idx,relation in enumerate(rule.body):

        # if ie relation split into two relations
        rel_type_terms_and_schema_list = []
        if isinstance(relation,Relation):
            rel_type_terms_and_schema_list.append(('relation',relation.terms,sess.relation_schemas[relation.name].scheme))
        elif isinstance(relation,IERelation):
            rel_type_terms_and_schema_list.append(('ie input relation',relation.in_terms,sess.ie_funcs[relation.name].in_schema))
            rel_type_terms_and_schema_list.append(('ie output relation',relation.out_terms,sess.ie_funcs[relation.name].out_schema))

        # for each relation type in the body relation
        for rel_type_terms_and_schema in rel_type_terms_and_schema_list:
            rel_type,terms,expected_schema = rel_type_terms_and_schema
            # for each term in the relation that is a free var
            for term_idx,(term,expected_type) in enumerate(zip(terms,expected_schema)):
                if isinstance(term,FreeVar):
                    # check if was defined before in other body relations
                    # if so must have same type as before
                    if term.name in free_var_to_type:
                        if free_var_to_type[term.name] != expected_type:
                            predefined_relation,predefined_term_idx = first_rel_to_define_free_var[term.name]
                            raise ValueError(f"In rule {pretty(rule)}, in body {rel_type} {pretty(relation)}, FreeVar {term.name} position {term_idx} expects type {pretty(expected_type)} "
                                            f"but was previously defined in relation {pretty(predefined_relation)} position {predefined_term_idx} with type {pretty(free_var_to_type[term.name])}")
                    # if not register it to the mapping
                    else:
                        free_var_to_type[term.name] = expected_type
                        first_rel_to_define_free_var[term.name] = (relation.name,term_idx)

    # for rule head, make sure all free vars are defined in the body
    # and if the rule head was used in another rule, make sure it has the same types
    head_name, head_terms = rule.head.name, rule.head.terms

    current_head_schema = []
    for term in head_terms:
        if not isinstance(term,FreeVar):
            raise ValueError(f"In rule {pretty(rule)}, in head clause {head_name}, only FreeVars are allowed")
        if not term.name in free_var_to_type:
            raise ValueError(f"In rule {pretty(rule)}, FreeVar {term.name} is used in the head but was not defined in the body")

    current_head_schema = RelationDefinition(name=head_name,scheme=[free_var_to_type[term.name] for term in head_terms])

    if head_name in sess.relation_schemas:
        expected_head_schema = sess.relation_schemas[head_name]
        if expected_head_schema != current_head_schema:
            raise ValueError(f"In rule {pretty(rule)}, expected schema {pretty(expected_head_schema)} from a previously defined rule to {head_name} but got {pretty(current_head_schema)}")

def consistent_free_var_types_in_rule(ast,sess):
    for match in rewrite_iter(ast,lhs='X[type="rule",val]'):
        rule = match['X']['val']
        _check_rule_consistency(rule,sess)
    return ast

# %% ../nbs/020_semantic_checks.ipynb 46
def is_rule_safe(rule:Rule):
    """
    Checks that the Spannerlog Rule is safe
    ---
    In spannerlog, rule safety is a semantic property that ensures that IE relation's inputs are limited 
    in the values they can be assigned to by other relations in the rule body.
    This could include outputs of other IE relations.

    We call a free variable in a rule body "bound" if it exists in the output of any safe relation in the rule body.
    For normal relations, they only have output terms, so all their free variables are considered bound.

    We call a relation in a rule's body safe if all its input free variables are bound.
    For normal relations, they don't have input relations, so they are always considered safe.

    We call a rule safe if all of its body relations are safe.

    This basically means that we need to make sure there is at least one order of IE relation evaluation, in which
    each IE relation input variables is bound by the normal relations and the output relation of the previous IE relations.

    Examples:
    * `rel2(X,Y) <- rel1(X,Z), ie1(X)->(Y)` is a safe rule as the only input free variable, `X`, exists in the output of the safe relation `rel1(X, Z)`.  
    * `rel2(Y) <- ie1(Z)->(Y)` is not safe as the input free variable `Z` does not exist in the output of any safe relation.
    * `rel2(Z,W) <- rel1(X,Y),ie1(Z,Y)->(W),ie2(W,Y)->Z` is not safe as both ie functions require each other's output as input, creating a circular dependency.
    ---
    """

    # get all free vars in regular relations
    normal_relations_free_vars = set()
    for body in rule.body:
        if isinstance(body,Relation):
            for term in body.terms:
                if isinstance(term,FreeVar):
                    normal_relations_free_vars.add(term.name)
    
    # get list of form [(ie_rel,{input_vars},{output_vars})]
    free_vars_per_ie_relation = {}
    for body in rule.body:
        if isinstance(body,IERelation):
            input_vars = set(term.name for term in body.in_terms if isinstance(term,FreeVar))
            output_vars = set(term.name for term in body.out_terms if isinstance(term,FreeVar))
            free_vars_per_ie_relation[body]=(input_vars,output_vars)
        
    # iteratively go over all previously unsafe ie relations and check if they are now safe

    safe_vars = normal_relations_free_vars.copy()
    safe_ie_relations = set()

    while True:
        if len(free_vars_per_ie_relation)==0:
            break
        
        safe_ie_relations_in_this_iteration = set()
        for ie_relation,(input_vars,output_vars) in free_vars_per_ie_relation.items():
            if input_vars.issubset(safe_vars):
                safe_ie_relations_in_this_iteration.add(ie_relation)
        
        if len(safe_ie_relations_in_this_iteration)== 0 :
            raise ValueError(f"Rule \'{pretty(rule)}\' is not safe:\n"
                            f"the following free vars where bound by normal relations: {normal_relations_free_vars}\n"
                            f"the following ie relations where safe: {safe_ie_relations}\n"
                            f"leading to the following free vars being bound: {safe_vars}\n"
                            f"However the following ie relations could not be bound: {[pretty(ie) for ie in free_vars_per_ie_relation.keys()]}\n"
                             )
    
        for ie_relation in safe_ie_relations_in_this_iteration:
            input_vars,output_vars = free_vars_per_ie_relation[ie_relation]
            safe_vars.update(output_vars)
            safe_ie_relations.add(ie_relation)
            del free_vars_per_ie_relation[ie_relation]



    return True

# %% ../nbs/020_semantic_checks.ipynb 56
def add_to_symbol_table(var_name,value,symbol_table):
    if var_name in symbol_table:
        existing_type,existing_value = symbol_table[var_name]
        if type(value) != existing_type:
            raise ValueError(f"Variable {var_name} was previously defined with {existing_value}({pretty(existing_type)})"
                             f" but is trying to be redefined to {value}({pretty(type(value))}) of a different type which might interfere with previous rule definitions")    
    symbol_table[var_name] = type(value),value
    return 


def assign_vars_to_symbol_table(ast,sess):
    for match in rewrite_iter(ast,lhs='''
                                statement[type="assignment"]-[idx=0]->var_name_node[type="var_name_lhs",val];
                                statement-[idx=1]->val_node[val]'''):
        var_name = match['var_name_node']['val'].name
        value = match['val_node']['val']
        add_to_symbol_table(var_name,value,sess.symbol_table)

    for match in rewrite_iter(ast,lhs='''
                                statement[type="read_assignment"]-[idx=0]->var_name_node[type="var_name_lhs",val];
                                statement-[idx=1]->val_node[val]'''):
        var_name = match['var_name_node']['val'].name
        path = match['val_node']['val']
        value = Path(path).read_text()
        add_to_symbol_table(var_name,value,sess.symbol_table)
    return ast

# %% ../nbs/020_semantic_checks.ipynb 59
def add_to_symbol_table(var_name,value,symbol_table):
    if var_name in symbol_table:
        existing_type,existing_value = symbol_table[var_name]
        if type(value) != existing_type:
            raise ValueError(f"Variable {var_name} was previously defined with {existing_value}({pretty(existing_type)})"
                             f" but is trying to be redefined to {value}({pretty(type(value))}) of a different type which might interfere with previous rule definitions")    
    symbol_table[var_name] = type(value),value
    return 


def assign_vars_to_symbol_table(ast,sess):
    for match in rewrite_iter(ast,lhs='''
                                statement[type="assignment"]-[idx=0]->var_name_node[type="var_name_lhs",val];
                                statement-[idx=1]->val_node[val]'''):
        var_name = match['var_name_node']['val'].name
        value = match['val_node']['val']
        add_to_symbol_table(var_name,value,sess.symbol_table)

    for match in rewrite_iter(ast,lhs='''
                                statement[type="read_assignment"]-[idx=0]->var_name_node[type="var_name_lhs",val];
                                statement-[idx=1]->val_node[val]'''):
        var_name = match['var_name_node']['val'].name
        path = match['val_node']['val']
        value = Path(path).read_text()
        add_to_symbol_table(var_name,value,sess.symbol_table)
    return ast

# %% ../nbs/020_semantic_checks.ipynb 67
class CheckReferencedRelationsExistenceAndArity(InterpreterPass):
    """
    A lark tree semantic check. <br>
    Checks whether each normal relation (that is not an ie relation) reference refers to a defined relation.
    Also checks if the relation reference uses the correct arity.
    """

    def __init__(self, symbol_table: SymbolTableBase, **kw: Any) -> None:
        super().__init__()
        self.symbol_table = symbol_table

    def _assert_relation_exists_and_correct_arity(self, relation: Relation) -> None:
        """
        A utility function that checks if a relation exists in the symbol table
        and if the correct arity was used.

        @param relation: the relation that will be checked.
        """

        # get the relation name and the arity that was used by the user
        relation_name = relation.relation_name
        used_arity = len(relation.term_list)

        # check if the relation exists using the symbol table
        if not self.symbol_table.contains_relation(relation_name):
            raise Exception(f'relation "{relation_name}" is not defined')

        # at this point we know the relation exists but we still need to check that the correct arity was used
        # get the correct arity
        relation_schema = self.symbol_table.get_relation_schema(relation_name)
        correct_arity = len(relation_schema)

        # check if that arity that was used is correct
        if used_arity != correct_arity:
            raise Exception(f'relation "{relation_name}" was referenced with an incorrect arity: {used_arity}. The '
                            f'correct arity is: {correct_arity}')

    @unravel_lark_node
    def query(self, query: Query) -> None:
        # a query is defined by a relation reference, so we can simply use the utility function
        self._assert_relation_exists_and_correct_arity(query)

    @unravel_lark_node
    def add_fact(self, fact: AddFact) -> None:
        # a fact is defined by a relation reference, so we can simply use the utility function
        self._assert_relation_exists_and_correct_arity(fact)

    @unravel_lark_node
    def remove_fact(self, fact: RemoveFact) -> None:
        # a fact is defined by a relation reference, so we can simply use the utility function
        self._assert_relation_exists_and_correct_arity(fact)

    @unravel_lark_node
    def rule(self, rule: Rule) -> None:
        """
        A rule is a definition of the relation in the rule head. Therefore the rule head reference does not
        need to be checked.
        The rule body references relations that should already exist. Those will be checked in this method.
        """

        # check that each normal relation in the rule body exists and that the correct arity was used
        for relation, relation_type in zip(rule.body_relation_list, rule.body_relation_type_list):
            if isinstance(relation, Relation):
                self._assert_relation_exists_and_correct_arity(relation)


# %% ../nbs/020_semantic_checks.ipynb 68
class CheckReferencedIERelationsExistenceAndArity(VisitorRecursivePass):
    """
    A lark tree semantic check. <br>
    Checks whether each ie relation reference refers to a defined ie function. <br>
    Also checks if the correct input arity and output arity for the ie function were used.

    Currently, an ie relation can only be found in a rule's body, so this is the only place where this
    check will be performed.
    """

    def __init__(self, symbol_table: SymbolTableBase, **kw: Any) -> None:
        super().__init__()
        self.symbol_table = symbol_table

    @unravel_lark_node
    def rule(self, rule: Rule) -> None:

        # for each ie relation in the rule body, check its existence and arity
        for relation, relation_type in zip(rule.body_relation_list, rule.body_relation_type_list):
            if isinstance(relation, IERelation):

                # get the name of the ie function, it is the same as the name of the ie relation
                ie_func_name = relation.relation_name

                # assert that the ie function exists
                if not self.symbol_table.contains_ie_function(ie_func_name):
                    raise Exception(f'the information extraction function "{ie_func_name}" does not exist')

                # the ie function exists, gets its data
                ie_func_data = self.symbol_table.get_ie_func_data(ie_func_name)

                # check if the correct input arity was used
                used_input_arity = len(relation.input_term_list)
                correct_input_arity = len(ie_func_data.get_input_types())
                if used_input_arity != correct_input_arity:
                    raise Exception(f'used incorrect input arity for ie function "{ie_func_name}":'
                                    f' {used_input_arity} (should be {correct_input_arity})')

                # check if the correct output arity was used
                used_output_arity = len(relation.output_term_list) + len(relation.input_term_list)
                correct_output_arity = len(ie_func_data.get_output_types(used_output_arity))
                if used_output_arity != correct_output_arity:
                    raise Exception(f'used incorrect output arity for ie function {ie_func_name}:'
                                    f' {used_output_arity} (should be {correct_output_arity})')


# %% ../nbs/020_semantic_checks.ipynb 70
class CheckRuleSafety(VisitorRecursivePass):
    """
    Performs semantic checks on rules using a Lark tree to ensure their safety. <br>
    A rule is considered "safe" when it meets certain conditions.


    * [Rule Safety Conditions](#rule-safety-conditions)
        * [Free Variable in Rule Head](#free-variable-in-rule-head)
        * [Bound Free Variable](#bound-free-variable)
    * [Examples](#examples)
    * [Safe Relations](#safe-relations)

    ---

    ### Rule Safety Conditions

    For a rule to be considered safe, the following two conditions must be met:

    ### 1. Free Variable in Rule Head

    Every free variable that appears in the rule head must occur at least once in the body as an output term of a relation.

    #### Examples

    * `parent(X,Y) <- son(X)` is not a safe rule because the free variable `Y` only appears in the rule head.  
    * `parent(X,Z) <- parent(X,Y), parent(Y,Z)` is a safe rule since both `X` and `Z` appear in the rule body.

    ### 2. Bound Free Variable

    A free variable is considered "bound" if it is constrained in a manner that limits the range of values it can take.

    To ensure that every free variable is bound, we must ensure that every relation in the rule body is a safe relation.

    ### Safe Relations

    A safe relation adheres to the following:

    * Its input relation is safe, meaning all its input's free variables are bound. Normal relations are always considered safe as they don't have input relations.  
    * A bound variable is one that exists in the output of a safe relation.

    #### Examples

    * `rel2(X,Y) <- rel1(X,Z), ie1<X>(Y)` is a safe rule as the only input free variable, `X`, exists in the output of the safe relation `rel1(X, Z)`.  
    * `rel2(Y) <- ie1<Z>(Y)` is not safe as the input free variable `Z` does not exist in the output of any safe relation.

    ---


    """

    def __init__(self, **kw: Any) -> None:
        super().__init__()

    @unravel_lark_node
    def rule(self, rule: Rule) -> None:
        head_relation = rule.head_relation
        body_relation_list = rule.body_relation_list
        body_relation_type_list = rule.body_relation_type_list

        # check condition 1:
        # every free variable in the head occurs at least once in the body as an output term of a relation.

        # get the free variables in the rule head
        rule_head_free_vars = get_free_var_names(head_relation.term_list, head_relation.type_list)

        # get the free variables in the rule body that serve as output terms.
        rule_body_output_free_var_sets = [get_output_free_var_names(relation) for relation in body_relation_list]
        rule_body_output_free_vars = set.union(*rule_body_output_free_var_sets)

        # make sure that every free variable in the rule head appears at least once as an output term
        # in the rule body
        bad_rule_head_free_vars = rule_head_free_vars.difference(rule_body_output_free_vars)
        if bad_rule_head_free_vars:
            raise Exception(f'The rule "{rule}" \n'
                            f'is not safe because the following free variables appear in the '
                            'rule head but not as output terms in the rule body:\n'
                            f'{bad_rule_head_free_vars}')

        # check condition 2:
        # every free variable is bound.

        # use a fix point iteration algorithm to find if all the free variables are bound:
        # a. iterate over all of the rule body relations and check if they are safe, meaning all their input
        # free variable terms are bound.
        # b. if a relation is safe, mark its output free variables as bound.
        # c. repeat step 'a' until no new bound free variables are found.

        def get_size_difference(set1: Set, set2: Set) -> int:
            """
            A utility function to be used as the distance function of the fixed point algorithm.

            @return: the size difference of set1 and set2.
            """
            size_difference = abs(len(set1) - len(set2))
            return size_difference

        def get_bound_free_vars(known_bound_free_vars: Set[str]) -> Set[str]:
            """
            a utility function to be used as the step function of the fixed point algorithm.
            this function iterates over all of the rule body relations, checking if each one of them is safe.
            if a rule is found to be safe, this function will mark its output free variables as bound.

            @param known_bound_free_vars: a set of the free variables in the rule that are known to be bound.
            @return: a union of 'known_bound_free_vars' with the bound free variables that were found.
            """

            for relation, relation_type in zip(rule.body_relation_list, rule.body_relation_type_list):
                # check if all of its input free variable terms of the relation are bound
                input_free_vars = get_input_free_var_names(relation)
                unbound_input_free_vars = input_free_vars.difference(known_bound_free_vars)
                if len(unbound_input_free_vars) == 0:
                    # all input free variables are bound, mark the relation's output free variables as bound
                    output_free_vars = get_output_free_var_names(relation)
                    known_bound_free_vars = known_bound_free_vars.union(output_free_vars)

            return known_bound_free_vars

        # get the bound free variables
        bound_free_vars = fixed_point(start=set(), step=get_bound_free_vars, distance=get_size_difference, thresh=0)

        # get all of the input free variables that were used in the rule body
        rule_body_input_free_var_sets = [get_input_free_var_names(relation)
                                         for relation, relation_type in
                                         zip(body_relation_list, body_relation_type_list)]
        rule_body_input_free_vars = set.union(*rule_body_input_free_var_sets)

        # assert there aren't any unbound free variables
        unbound_free_vars = rule_body_input_free_vars.difference(bound_free_vars)
        if unbound_free_vars:
            # condition 2 check failed, get all of the unbound free variables and pass them in an exception
            raise Exception(f'The rule "{rule}" \n'
                            f'is not safe because the following free variables are not bound:\n'
                            f'{unbound_free_vars}')



# %% ../nbs/020_semantic_checks.ipynb 72
class TypeCheckAssignments(InterpreterPass):
    """
    A lark semantic check <br>
    performs type checking for `Assignments` <br>
    in the current version of lark, this type checking is only required for read assignments.
    """

    def __init__(self, symbol_table: SymbolTableBase, **kw: Any) -> None:
        super().__init__()
        self.symbol_table = symbol_table

    @unravel_lark_node
    def read_assignment(self, assignment: ReadAssignment) -> None:

        # get the type of the argument for the read() function
        if assignment.read_arg_type is DataTypes.var_name:
            read_arg_var_name = assignment.read_arg
            read_arg_type = self.symbol_table.get_variable_type(read_arg_var_name)
        else:
            read_arg_type = assignment.read_arg_type

        # if the argument is not of type string, raise and exception
        if read_arg_type is not DataTypes.string:
            raise Exception(f'type checking failed for the read assignment {assignment}\n'
                            f'because the argument type for read() was {read_arg_type} (must be a string)')


# %% ../nbs/020_semantic_checks.ipynb 74
class TypeCheckRelations(InterpreterPass):
    """
    A Lark Tree Semantic Check

    ### Assumptions

    This pass operates under the following assumptions. Failure to meet these may lead to incorrect results:

    1. References to relations and IE (Information Extraction) relations, as well as their arity, have been properly checked.
    2. Variable references have been verified.
    3. The pass only processes a single statement as input.

    ### Semantic Checks

    The pass performs the following specific checks:

    #### 1. Typed Relation References

    It verifies if the relation references in the rule are correctly typed.

    #### 2. Typed IE Relations

    It verifies if the IE relations in the rule are correctly typed.

    #### 3. Conflicting Types in Free Variables

    Checks if free variables within rules have conflicting types. This is crucial to ensure that the rules are logically coherent.

    ### Example

    Here is an example that illustrates how a semantic check may fail on the third type of check:

    ```prolog
    new A(str)
    new B(int)
    C(X) <- A(X), B(X)  # Error: X is expected to be both an int and a string.
    ```
    """

    def __init__(self, symbol_table: SymbolTableBase, **kw: Any) -> None:
        super().__init__()
        self.symbol_table = symbol_table

    @unravel_lark_node
    def add_fact(self, fact: AddFact) -> None:
        # a fact is defined by a relation, check if that relation is properly typed
        type_check_passed = check_properly_typed_relation(fact, self.symbol_table)
        if not type_check_passed:
            raise Exception(f'type check failed for fact: "{fact}"')

    @unravel_lark_node
    def remove_fact(self, fact: RemoveFact) -> None:
        # a fact is defined by a relation, check if that relation is properly typed
        type_check_passed = check_properly_typed_relation(fact, self.symbol_table)
        if not type_check_passed:
            raise Exception(f'type check failed for fact: "{fact}"')

    @unravel_lark_node
    def query(self, query: Query) -> None:
        # a query is defined by a relation, check if that relation is properly typed
        type_check_passed = check_properly_typed_relation(query, self.symbol_table)
        if not type_check_passed:
            raise Exception(f'type check failed for query: "{query}"')

    @unravel_lark_node
    def rule(self, rule: Rule) -> None:

        # for each relation in the rule body, check if it is properly typed, raise an exception if it isn't
        for relation, relation_type in zip(rule.body_relation_list, rule.body_relation_type_list):
            relation_is_properly_typed = check_properly_typed_relation(relation, self.symbol_table)
            if not relation_is_properly_typed:
                raise Exception(f'type check failed for rule "{rule}"\n'
                                f'because the relation "{relation}"\n'
                                f'is not properly typed')

        # check for free variables with conflicting type in the rule, raise an exception if there are any
        _, conflicted_free_vars = type_check_rule_free_vars(rule, self.symbol_table)
        if conflicted_free_vars:
            raise Exception(f'type check failed for rule "{rule}"\n'
                            f'because the following free variables have conflicting types:\n'
                            f'{conflicted_free_vars}')


# %% ../nbs/020_semantic_checks.ipynb 76
class SaveDeclaredRelationsSchemas(InterpreterPass):
    """
    This pass writes the relation schemas that it finds in relation declarations and rule heads* to the
    symbol table.

    This pass assumes that type checking was already performed on its input.
    """

    def __init__(self, symbol_table: SymbolTableBase, **kw: Any) -> None:
        super().__init__()
        self.symbol_table = symbol_table

    @unravel_lark_node
    def relation_declaration(self, relation_decl: RelationDeclaration) -> None:
        self.symbol_table.add_relation_schema(relation_decl.relation_name, relation_decl.type_list, False)

    @no_type_check
    @unravel_lark_node
    def rule(self, rule: Rule) -> None:
        # a rule head relation only contains free variable terms, meaning its schema is defined exclusively by the
        # types of said free variables. a free variable type in a rule can be found using the schemas of relations
        # in the rule body
        # get a mapping from a free variable in this rule to its type
        free_var_to_type, _ = type_check_rule_free_vars(rule, self.symbol_table)

        # get the schema of the rule head relation and add it to the symbol table
        head_relation = rule.head_relation
        term_list = head_relation.term_list
        rule_head_schema = [free_var_to_type[term] for term in term_list]
        self.symbol_table.add_relation_schema(head_relation.relation_name, rule_head_schema, True)


# %% ../nbs/020_semantic_checks.ipynb 79
class ResolveVariablesReferences(InterpreterPass):
    """
    A lark execution pass, <br>
    this pass replaces variable references with their literal values. <br>
    also replaces `DataTypes.var_name` types with the real type of the variable.
    """

    def __init__(self, symbol_table: SymbolTableBase, **kw: Any) -> None:
        super().__init__()
        self.symbol_table = symbol_table

    @unravel_lark_node
    def assignment(self, assignment: Assignment) -> None:
        # if the assigned value is a variable, replace it with its literal value
        if assignment.value_type is DataTypes.var_name:
            assigned_value = assignment.value
            assignment.value = self.symbol_table.get_variable_value(assigned_value)
            assignment.value_type = self.symbol_table.get_variable_type(assigned_value)

    @unravel_lark_node
    def read_assignment(self, assignment: ReadAssignment) -> None:
        # if the read() argument is a variable, replace it with its literal value
        if assignment.read_arg_type is DataTypes.var_name:
            read_arg_var_name = assignment.read_arg
            assignment.read_arg = self.symbol_table.get_variable_value(read_arg_var_name)
            assignment.read_arg_type = self.symbol_table.get_variable_type(read_arg_var_name)

    @no_type_check
    def _resolve_var_terms(self, term_list: Sequence[DataTypeMapping.term], type_list: Sequence[DataTypes]) -> None:
        """
        A utility function for resolving variables in term lists
        for each variable term in term_list, replace its value in term_list with its literal value, and
        its DataTypes.var_name type in type_list with its real type
        the changes to the lists are done in-place.

        @param term_list: a list of terms.
        @param type_list: the type of terms in term_list.
        """

        # get the list of terms with resolved variable values
        resolved_var_values_term_list = [
            self.symbol_table.get_variable_value(term) if term_type is DataTypes.var_name
            else term
            for term, term_type in zip(term_list, type_list)]

        # get the list of types with resolved variable types
        resolved_var_types_type_list = [
            self.symbol_table.get_variable_type(term) if term_type is DataTypes.var_name
            else term_type
            for term, term_type in zip(term_list, type_list)]

        # replace the lists with the resolved lists. use slicing to do it in-place.
        term_list[:] = resolved_var_values_term_list
        type_list[:] = resolved_var_types_type_list

    @unravel_lark_node
    def query(self, query: Query) -> None:
        self._resolve_var_terms(query.term_list, query.type_list)

    @unravel_lark_node
    def add_fact(self, fact: AddFact) -> None:
        self._resolve_var_terms(fact.term_list, fact.type_list)

    @unravel_lark_node
    def remove_fact(self, fact: RemoveFact) -> None:
        self._resolve_var_terms(fact.term_list, fact.type_list)

    @unravel_lark_node
    def rule(self, rule: Rule) -> None:
        # resolve the variables of each relation in the rule body relation list
        for relation, relation_type in zip(rule.body_relation_list, rule.body_relation_type_list):
            if isinstance(relation, Relation):
                self._resolve_var_terms(relation.term_list, relation.type_list)
            elif isinstance(relation, IERelation):
                # ie relations have two term lists (input and output), resolve them both
                self._resolve_var_terms(relation.input_term_list, relation.input_type_list)
                self._resolve_var_terms(relation.output_term_list, relation.output_type_list)
            else:
                raise Exception(f'unexpected relation type: {relation_type}')


# %% ../nbs/020_semantic_checks.ipynb 81
class ExecuteAssignments(InterpreterPass):
    """
    A lark execution pass, <br>
    executes assignments by saving variables' values and types in the symbol table <br>
    should be used only after variable references are resolved, meaning the assigned values and read() arguments
    are guaranteed to be literals.
    """

    def __init__(self, symbol_table: SymbolTableBase, **kw: Any) -> None:
        super().__init__()
        self.symbol_table = symbol_table

    @unravel_lark_node
    def assignment(self, assignment: Assignment) -> None:
        # perform the assignment by saving the variable attributes in the symbol table
        self.symbol_table.set_var_value_and_type(assignment.var_name, assignment.value, assignment.value_type)

    @unravel_lark_node
    def read_assignment(self, assignment: ReadAssignment) -> None:
        # try to read the file and get its content as a single string. this string is the assigned value.
        try:
            assigned_value = Path(assignment.read_arg).read_text()
        except Exception:
            raise Exception(f'could not open file "{assignment.read_arg}"')

        # perform the assignment by saving the variable attributes in the symbol table
        # note that since this is a read assignment, the type of the variable will always be a string
        self.symbol_table.set_var_value_and_type(assignment.var_name, assigned_value, DataTypes.string)


# %% ../nbs/020_semantic_checks.ipynb 84
#TODO agg - rewrite this to not exist? and if it exist use a naive netx graph
class AddStatementsToNetxParseGraph(InterpreterPass):
    """
    A lark execution pass. <br>
    This pass adds each statement in the input parse tree to the parse graph. <br>
    This pass is made to work with execution.naive_execution as the execution function and
    `term_graph.NetxStateGraph` as the parse graph.

    Each statement in the parse graph will be a child of the parse graph's root.

    Each statement in the parse graph will have a type attribute that contains the statement's name in the
    spannerlog grammar.

    Some nodes in the parse graph will contain a value attribute that would contain a relation that describes
    that statement.
    e.g. a `add_fact` node would have a value which is a `structured_nodes.AddFact` instance
    (which inherits from `structured_nodes.Relation`) that describes the fact that will be added.

    Some statements are more complex and will be described by more than a single node, e.g. a rule node.
    The reason for this is that we want a single netx node to not contain more than one Relation
    (or `IERelation`) instance. This will make the parse graph a "graph of relation nodes", allowing
    for flexibility for optimization in the future.
    """

    def __init__(self, parse_graph, **kw: Any) -> None:
        super().__init__()
        self.parse_graph = parse_graph

    def _add_statement_to_parse_graph(self, statement_type: ParseNodeType, statement_value: Any) -> None:
        """
        A utility function that adds a statement to the parse graph, meaning it adds a node that
        represents the statement to the parse graph, then attach the node to the parse graph's root.
        Should only be used for simple statements (i.e. can be described by a single node).

        @param statement_type: the type of the statement, (e.g. add_fact). should be the same as the statement's
                               name in the grammar. Will be set as the node's type attribute.
        @param statement_value: will be set as the value attribute of the node.
        """
        new_statement_node = self.parse_graph.add_node(type=statement_type, value=statement_value)
        self.parse_graph.add_edge(self.parse_graph.get_root_id(), new_statement_node)

    @unravel_lark_node
    def add_fact(self, fact: AddFact) -> None:
        self._add_statement_to_parse_graph(ParseNodeType.ADD_FACT, fact)

    @unravel_lark_node
    def remove_fact(self, fact: RemoveFact) -> None:
        self._add_statement_to_parse_graph(ParseNodeType.REMOVE_FACT, fact)

    @unravel_lark_node
    def query(self, query: Query) -> None:
        self._add_statement_to_parse_graph(ParseNodeType.QUERY, query)

    @unravel_lark_node
    def relation_declaration(self, relation_decl: RelationDeclaration) -> None:
        self._add_statement_to_parse_graph(ParseNodeType.RELATION_DECLARATION, relation_decl)

    @unravel_lark_node
    def rule(self, rule: Rule) -> None:
        self._add_statement_to_parse_graph(ParseNodeType.RULE, rule)

