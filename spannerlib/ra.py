# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/008_extended_RA_operations.ipynb.

# %% auto 0
__all__ = ['logger', 'equalConstTheta', 'equalColTheta', 'get_const', 'select', 'project', 'rename', 'union', 'intersection',
           'difference', 'join', 'product', 'assert_ie_output_schema', 'map_iter', 'ie_map']

# %% ../nbs/008_extended_RA_operations.ipynb 4
import pytest
import pandas as pd
import numpy as np
from typing import no_type_check, Set, Sequence, Any,Optional,List,Callable,Dict,Union
import networkx as nx
import itertools

from .utils import serialize_df_values
from .span import Span
from .data_types import _infer_relation_schema,pretty

import logging
logger = logging.getLogger(__name__)

# %% ../nbs/008_extended_RA_operations.ipynb 5
def _col_names(length):
    # these names wont conflixt with logical variables since they must always start with Uppercase letters
    return [f'col_{i}' for i in range(length)]



# %% ../nbs/008_extended_RA_operations.ipynb 9
# some select theta functions

class equalConstTheta():
    def __init__(self,*pos_val_tuples):
        self.pos_val_tuples = pos_val_tuples
    def __call__(self,df):
        masks = [df.iloc[:,pos]==val for pos,val in self.pos_val_tuples]
        return pd.concat(masks,axis=1).all(axis=1)
    def __str__(self):
        return f'''Theta({', '.join([f'col_{pos}={val}' for pos,val in self.pos_val_tuples])})'''
    def __repr__(self):
        return str(self)
    def __eq__(self,other):
        if not isinstance(other,equalConstTheta):
            return False
        return self.pos_val_tuples == other.pos_val_tuples

class equalColTheta():
    def __init__(self,*col_pos_tuples):
        self.col_pos_tuples = col_pos_tuples

    def __call__(self,df):
        masks = [df.iloc[:,pos1]==df.iloc[:,pos2] for pos1,pos2 in self.col_pos_tuples]
        return pd.concat(masks,axis=1).all(axis=1)    
    def __str__(self):
        return f'''Theta({', '.join([f'col_{pos1}=col_{pos2}' for pos1,pos2 in self.col_pos_tuples])})'''
    def __repr__(self):
        return str(self)
    def __eq__(self,other):
        if not isinstance(other,equalColTheta):
            return False
        return self.col_pos_tuples == other.col_pos_tuples

# %% ../nbs/008_extended_RA_operations.ipynb 13
def get_const(const_dict):
    return pd.DataFrame([const_dict])

# %% ../nbs/008_extended_RA_operations.ipynb 16
def select(df,theta,**kwargs):
    if df.empty:
        return df

    if callable(theta):
        return df[theta(df)]
    else:
        raise ValueError(f"theta must be callable, got {theta}")

def project(df,on=None,not_on=None,**kwargs):
    if df.empty and len(df.columns)==0:
        return df
    if on is None and not_on is None:
        raise Value("either on or not_on must be specified")
    if on is not None:
        return df[on]
    else:
        return df.drop(columns=not_on)

def rename(df,names,**kwargs):
    if df.empty and len(df.columns)==0:
        return df
    names_mapper = {
    }
    current_col_names = list(df.columns)
    for i,name in names:
        names_mapper[current_col_names[i]] = name
    return df.rename(names_mapper,axis=1)

def union(*dfs,**kwargs):
    # use numpy arrays to ignore column names
    non_empty_dfs = [df for df in dfs if not df.empty]
    return pd.DataFrame(np.concatenate(non_empty_dfs,axis=0)).drop_duplicates()

def intersection(df1,df2,**kwargs):
    return pd.merge(df1,df2,how='inner',on=list(df1.columns))

def difference(df1,df2,**kwargs):
    return pd.concat([df1,df2]).drop_duplicates(keep=False)

def join(df1,df2,**kwargs):
    cols1 = set(df1.columns)
    cols2 = set(df2.columns)
    on = cols1 & cols2
    # get only logical variables
    on = [ col for col in on if isinstance(col,str) and col[0].isupper()]
    if len(on)==0:
        return pd.merge(df1,df2,how='cross')
    else:
        return pd.merge(df1,df2,how='inner',on=on)

def product(df1,df2,**kwargs):
    return pd.merge(df1,df2,how='cross')

# %% ../nbs/008_extended_RA_operations.ipynb 38
def assert_ie_output_schema(name,func,input,output,expected_schema):
    """helper function for asserting the output schema of an ie function
    expected schema is either a callable that takes input and output and 
    raises error if the output is notvalid, or a fixed list of column names

    Args:
        input (_type_): input relation
        output (_type_): output relation from ie function
        expected_schema (_type_): output schema object

    Raises:
        ValueError: _description_
        ValueError: _description_
    """
    if not isinstance(output,(tuple,list)):
        raise ValueError(f"IEFunction {name} with underlying function {func}\n"
                         f"returned a value that is not a tuple/list\n"
                         f"for input output pair ({input},{output})"
                         f"did you remember to return the output as a tuple/list?")
    if callable(expected_schema):# out schema is a callable
        if not expected_schema(output,input):
            raise ValueError(f"When validating output schema using {expected_schema} for input output pair ({input},{output}), the output was invalid")
    else: # out schema is a fixed list
        if _infer_relation_schema(output) != expected_schema:
            raise ValueError(
                f"IEFunction {name} with underlying function {func}\n"
                f"returned a value of an unexpected schema {pretty(_infer_relation_schema(output))}\n"
                f"for input output pair ({input},{output})"
                f"expected {pretty(expected_schema)}")


def map_iter(df,name,func,in_schema,out_schema,**kwargs):
    """helper function returns an iterator that applies a function to each row of a dataframe
    """
    first_out_schema = None
    for _,in_row in df.iterrows():
        in_row = list(in_row)
        for out_row in func(*in_row):
            assert_ie_output_schema(name,func,in_row,out_row,out_schema)
            yield in_row + list(out_row)

def ie_map(df,name,func,in_schema,out_schema,combined_term_len,**kwargs):
    """given an indexed dataframe, apply an ie function to each row and return the output 
    such that each output relation is indexed by the same index as the input relation that generated it
    """
    # if df.empty:
    #     return df
    output_iter = map_iter(df,name,func,in_schema,out_schema)
    return pd.DataFrame(output_iter,columns=_col_names(combined_term_len))




