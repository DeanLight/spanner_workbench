# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/008_extended_RA_operations.ipynb.

# %% auto 0
__all__ = ['logger', 'select', 'project', 'rename', 'union', 'intersection', 'difference', 'join', 'index',
           'assert_ie_output_schema', 'map_iter', 'ie_map']

# %% ../nbs/008_extended_RA_operations.ipynb 4
import pytest
import pandas as pd
from typing import no_type_check, Set, Sequence, Any,Optional,List,Callable,Dict,Union
import networkx as nx
import itertools

from .utils import serialize_df_values
from .data_types import _infer_relation_schema,pretty

import logging
logger = logging.getLogger(__name__)

# %% ../nbs/008_extended_RA_operations.ipynb 5
def _col_names(length):
    # these names wont conflixt with logical variables since they must always start with Uppercase letters
    return [f'col{i}' for i in range(length)]



# %% ../nbs/008_extended_RA_operations.ipynb 9
def select(df,theta,**kwargs):
    if df.empty:
        return df

    if callable(theta):
        return df[theta(df)]
    else:
        pos_val_pairs = theta
        for pos,val in pos_val_pairs:
            df = df[df.iloc[:,pos] == val]
        return df

def project(df,on=None,not_on=None,**kwargs):
    if df.empty:
        return df
    if on is None and not_on is None:
        raise Value("either on or not_on must be specified")
    if on is not None:
        return df[on]
    else:
        return df.drop(columns=not_on)

def rename(df,names,**kwargs):
    if df.empty:
        return df
    names_mapper = {
    }
    current_col_names = list(df.columns)
    for i,name in names:
        names_mapper[current_col_names[i]] = name
    return df.rename(names_mapper,axis=1)

def union(*dfs,**kwargs):
    return pd.concat(dfs).drop_duplicates()

def intersection(df1,df2,**kwargs):
    return pd.merge(df1,df2,how='inner',on=list(df1.columns))

def difference(df1,df2,**kwargs):
    return pd.concat([df1,df2]).drop_duplicates(keep=False)

def join(df1,df2,**kwargs):
    cols1 = set(df1.columns)
    cols2 = set(df2.columns)
    on = cols1 & cols2
    # get only logical variables
    on = [ col for col in on if isinstance(col,str) and col[0].isupper()]
    if len(on)==0:
        return pd.merge(df1,df2,how='cross')
    else:
        return pd.merge(df1,df2,how='inner',on=on)


# %% ../nbs/008_extended_RA_operations.ipynb 28
def index(df,key_col_name='index',**kwargs):
    # and an "index" operator that adds an uniq index with a key to a given column
    index_series = pd.Series(range(len(df)),name=key_col_name)
    return pd.concat([df,index_series],axis=1)

# %% ../nbs/008_extended_RA_operations.ipynb 29
def assert_ie_output_schema(input,output,expected_schema):
    """helper function for asserting the output schema of an ie function
    expected schema is either a callable that takes input and output and 
    raises error if the output is notvalid, or a fixed list of column names

    Args:
        input (_type_): input relation
        output (_type_): output relation from ie function
        expected_schema (_type_): output schema object

    Raises:
        ValueError: _description_
        ValueError: _description_
    """
    if callable(expected_schema):# out schema is a callable
        if not expected_schema(output,input):
            raise ValueError(f"When validating output schema using {expected_schema} for input output pair ({input},{output}), the output was invalid")
    else: # out schema is a fixed list
        if _infer_relation_schema(output) != expected_schema:
            raise ValueError(
                f"IEFunction returned a value of an unexpected schema {pretty(_infer_relation_schema(output))} "
                f"for input output pair ({input},{output})"
                f"expected {pretty(expected_schema)}")


def map_iter(df,func,out_schema,**kwargs):
    """helper function returns schema of output, and then the output rows as an iterator
    """
    first_out_schema = None
    for _,in_row in df.iterrows():
        in_row = list(in_row)
        index = in_row[-1]
        ie_input = in_row[:-1]
        for out_row in func(*ie_input):
            assert_ie_output_schema(ie_input,out_row,out_schema)
            if first_out_schema is None:
                first_out_schema = _infer_relation_schema(out_row)
                yield first_out_schema
            index_out_put = list(out_row) + [index]
            yield index_out_put

def ie_map(df,func,out_schema,index_name ='index',**kwargs):
    """given an indexed dataframe, apply an ie function to each row and return the output 
    such that each output relation is indexed by the same index as the input relation that generated it
    """
    if df.empty:
        return df
    output_iter = map_iter(df,func,out_schema)
    schema = next(output_iter)
    num_cols = len(schema)
    return pd.DataFrame(output_iter,columns=_col_names(num_cols)+[index_name])




