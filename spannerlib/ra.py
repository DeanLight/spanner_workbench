# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/008_extended_RA_operations.ipynb.

# %% auto 0
__all__ = ['logger', 'equalConstTheta', 'equalColTheta', 'get_const', 'select', 'project', 'rename', 'union', 'intersection',
           'difference', 'join', 'product', 'assert_ie_output_schema', 'map_iter', 'ie_map']

# %% ../nbs/008_extended_RA_operations.ipynb 4
import pytest
import pandas as pd
from typing import no_type_check, Set, Sequence, Any,Optional,List,Callable,Dict,Union
import networkx as nx
import itertools

from .utils import serialize_df_values
from .span import Span
from .data_types import _infer_relation_schema,pretty

import logging
logger = logging.getLogger(__name__)

# %% ../nbs/008_extended_RA_operations.ipynb 5
def _col_names(length):
    # these names wont conflixt with logical variables since they must always start with Uppercase letters
    return [f'col_{i}' for i in range(length)]



# %% ../nbs/008_extended_RA_operations.ipynb 9
# some select theta functions

class equalConstTheta():
    def __init__(self,*pos_val_tuples):
        self.pos_val_tuples = pos_val_tuples
    def __call__(self,df):
        masks = [df.iloc[:,pos]==val for pos,val in self.pos_val_tuples]
        return pd.concat(masks,axis=1).all(axis=1)
    def __str__(self):
        return f'''Theta({', '.join([f'col_{pos}={val}' for pos,val in self.pos_val_tuples])})'''
    def __repr__(self):
        return str(self)
    def __eq__(self,other):
        if not isinstance(other,equalConstTheta):
            return False
        return self.pos_val_tuples == other.pos_val_tuples

class equalColTheta():
    def __init__(self,*col_pos_tuples):
        self.col_pos_tuples = col_pos_tuples

    def __call__(self,df):
        masks = [df.iloc[:,pos1]==df.iloc[:,pos2] for pos1,pos2 in self.col_pos_tuples]
        return pd.concat(masks,axis=1).all(axis=1)    
    def __str__(self):
        return f'''Theta({', '.join([f'col_{pos1}=col_{pos2}' for pos1,pos2 in self.col_pos_tuples])})'''
    def __repr__(self):
        return str(self)
    def __eq__(self,other):
        if not isinstance(other,equalColTheta):
            return False
        return self.col_pos_tuples == other.col_pos_tuples

# %% ../nbs/008_extended_RA_operations.ipynb 13
def get_const(const_dict):
    return pd.DataFrame([const_dict])

# %% ../nbs/008_extended_RA_operations.ipynb 16
def select(df,theta,**kwargs):
    if df.empty:
        return df

    if callable(theta):
        return df[theta(df)]
    else:
        raise ValueError(f"theta must be callable, got {theta}")

def project(df,on=None,not_on=None,**kwargs):
    if df.empty:
        return df
    if on is None and not_on is None:
        raise Value("either on or not_on must be specified")
    if on is not None:
        return df[on]
    else:
        return df.drop(columns=not_on)

def rename(df,names,**kwargs):
    if df.empty:
        return df
    names_mapper = {
    }
    current_col_names = list(df.columns)
    for i,name in names:
        names_mapper[current_col_names[i]] = name
    return df.rename(names_mapper,axis=1)

def union(*dfs,**kwargs):
    return pd.concat(dfs).drop_duplicates()

def intersection(df1,df2,**kwargs):
    return pd.merge(df1,df2,how='inner',on=list(df1.columns))

def difference(df1,df2,**kwargs):
    return pd.concat([df1,df2]).drop_duplicates(keep=False)

def join(df1,df2,**kwargs):
    cols1 = set(df1.columns)
    cols2 = set(df2.columns)
    on = cols1 & cols2
    # get only logical variables
    on = [ col for col in on if isinstance(col,str) and col[0].isupper()]
    if len(on)==0:
        return pd.merge(df1,df2,how='cross')
    else:
        return pd.merge(df1,df2,how='inner',on=on)

def product(df1,df2,**kwargs):
    return pd.merge(df1,df2,how='cross')

# %% ../nbs/008_extended_RA_operations.ipynb 36
def assert_ie_output_schema(input,output,expected_schema):
    """helper function for asserting the output schema of an ie function
    expected schema is either a callable that takes input and output and 
    raises error if the output is notvalid, or a fixed list of column names

    Args:
        input (_type_): input relation
        output (_type_): output relation from ie function
        expected_schema (_type_): output schema object

    Raises:
        ValueError: _description_
        ValueError: _description_
    """
    if callable(expected_schema):# out schema is a callable
        if not expected_schema(output,input):
            raise ValueError(f"When validating output schema using {expected_schema} for input output pair ({input},{output}), the output was invalid")
    else: # out schema is a fixed list
        if _infer_relation_schema(output) != expected_schema:
            raise ValueError(
                f"IEFunction returned a value of an unexpected schema {pretty(_infer_relation_schema(output))} "
                f"for input output pair ({input},{output})"
                f"expected {pretty(expected_schema)}")


def map_iter(df,func,in_schema,out_schema,**kwargs):
    """helper function returns schema of output, and then the output rows as an iterator
    """
    first_out_schema = None
    for _,in_row in df.iterrows():
        in_row = list(in_row)
        for out_row in func(*in_row):
            assert_ie_output_schema(in_row,out_row,out_schema)
            if first_out_schema is None:
                first_out_schema = _infer_relation_schema(out_row)
                yield in_schema + first_out_schema
            yield in_row + list(out_row)

def ie_map(df,func,in_schema,out_schema,**kwargs):
    """given an indexed dataframe, apply an ie function to each row and return the output 
    such that each output relation is indexed by the same index as the input relation that generated it
    """
    if df.empty:
        return df
    output_iter = map_iter(df,func,in_schema,out_schema)
    schema = next(output_iter)
    num_cols = len(schema)
    return pd.DataFrame(output_iter,columns=_col_names(num_cols))




