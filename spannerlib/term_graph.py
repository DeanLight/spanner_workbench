# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/009_term_graphs.ipynb.

# %% auto 0
__all__ = ['logger', 'add_select_constants', 'add_product_constants', 'add_relation', 'add_ie_relation', 'get_bounding_order',
           'rule_to_graph', 'graph_compose', 'merge_term_graphs_pair', 'merge_term_graphs']

# %% ../nbs/009_term_graphs.ipynb 3
from IPython.display import display
import pandas as pd
import os
import networkx as nx
import itertools
import logging
import pytest
from collections import defaultdict
logger = logging.getLogger(__name__)

from graph_rewrite import draw

from .utils import checkLogs,serialize_df_values,serialize_graph,get_new_node_name
from .span import Span
from .ra import equalConstTheta,equalColTheta
from spannerlib.data_types import (
    _infer_relation_schema,
    Var,
    FreeVar,
    RelationDefinition,
    Relation,
    IEFunction,
    IERelation,
    Rule,
    pretty,
)

# %% ../nbs/009_term_graphs.ipynb 8
def add_select_constants(g,source,terms):
    """
    adds a select node as a father to source, with the constant terms defined in terms
    if no constant terms are defined, does nothing
    returns the select node if it was added or the source not if not


    Example - R(X,3):
    source <- select(theta(col1=3))
    """
    need_select = any(not isinstance(term,FreeVar) for term in terms)
    if not need_select:
        return source
    
    select_pos_val = list()
    for i,term in enumerate(terms):
        if not isinstance(term,FreeVar):
            select_pos_val.append((i,term))
    
    select_name = get_new_node_name(g)
    g.add_node(select_name, op='select',theta=equalConstTheta(*select_pos_val))
    g.add_edge(select_name,source)
    return select_name

def add_product_constants(g,source,terms):
    """
    adds a product node as a father to source, with the constant terms defined in terms
    if no constant terms are defined, does nothing
    returns the product node if it was added or the source not if not

    Example - F(X,3,Y,4)->(Z):
    source                       <- product() <- project(on=[X,_C1,Y,_C2])
    get_const({'_C1':3,'_C2':4}) <- 

    example 2 - F(3,4)->(Z):
        get_const({'_C1':3,'_C2':4})


    """
    has_consts = any(not isinstance(term,FreeVar) for term in terms)
    has_vars = any(isinstance(term,FreeVar) for term in terms)
    if has_vars and not has_consts:
        return source
    

    product_pos_val = list()
    for i,term in enumerate(terms):
        if not isinstance(term,FreeVar):
            product_pos_val.append((i,term))
    
    const_dict = {f'_C{i}':val for i,val in product_pos_val}

    const_node = get_new_node_name(g)
    g.add_node(const_node, op='get_const',const_dict = const_dict)

    if has_consts and not has_vars:
        return const_node


    product_node = get_new_node_name(g)
    g.add_node(product_node, op='product')
    g.add_edge(product_node,source)
    g.add_edge(product_node,const_node)

    project_node = get_new_node_name(g)
    project_order = []
    for i,term in enumerate(terms):
        if isinstance(term,FreeVar):
            project_order.append(term.name)
        else:
            project_order.append(f'_C{i}')
    g.add_node(project_node, op='project',on=project_order)
    g.add_edge(project_node,product_node)
    
    return project_node



# %% ../nbs/009_term_graphs.ipynb 12
def add_relation(g,rel):
    """
    adds a relation to the graph
    WLOG a relation of the form R(X,Y,const)
    should be of the abstract form get(R)<-rename(0:X,1:Y)<-select(2:const)<-project(on=[X,Y])

    returns (top most node, bottom most node) 
    """

    g.add_node(rel.name,rel=rel.name)
    rename_node = get_new_node_name(g)
    g.add_node(rename_node, op='rename',names=[(i,term.name) for i,term in enumerate(rel.terms) if isinstance(term,FreeVar)])
    g.add_edge(rename_node,rel.name)
    select_node = add_select_constants(g,rename_node,rel.terms)
    if select_node == rename_node:
        return (rename_node,rel.name)
    project_node = get_new_node_name(g)
    g.add_node(project_node, op='project',on=[term.name for term in rel.terms if isinstance(term,FreeVar)])
    g.add_edge(project_node,select_node)
    return (project_node,rel.name)

def add_ie_relation(g,rel):
    """
    adds an ie relation to the graph
    WLOG a relation of the form f(X,Y,c1)->(Z,X,c2)
    should be of the abstract form 
    project(X,Y)          <- product()<-projecton=[X,Y,_C2]<-ie_map(f)<-select(col_5==c2)<-select(col_0==col_4)<-rename(0:X,1:Y,3:Z)<-project(on=[X,Y,Z])
    get_const({'_C2':c1}) <-
    returns (top most node, bottom most node)
    """
    ie_has_variable_inputs = any(isinstance(term,FreeVar) for term in rel.in_terms)
    if ie_has_variable_inputs:
        project_input_vars = get_new_node_name(g)
        g.add_node(project_input_vars, op='project',on=[term.name for term in rel.in_terms if isinstance(term,FreeVar)])
    else:
        project_input_vars = None
    product_node = add_product_constants(g,project_input_vars,rel.in_terms)
    ie_map_node = get_new_node_name(g)
    g.add_node(ie_map_node, op='ie_map',func=rel.name,in_arity=len(rel.in_terms),out_arity=len(rel.out_terms))
    g.add_edge(ie_map_node,product_node)

    # we will get combined input+output relation from the ie map so now we reason based on it

    combined_terms = rel.in_terms+rel.out_terms
    
    # we only need to select on the output constants, since the input constants where generated via the product
    # so we mask the input terms
    masked_input_combined_terms = [FreeVar(name='_F')]*len(rel.in_terms)+rel.out_terms
    select_node = add_select_constants(g,ie_map_node,masked_input_combined_terms)

    # select on equal free vars assignments for freevars with the same name
    column_pairs_with_equal_free_vars = []
    for (i,term1),(j,term2) in itertools.combinations(enumerate(combined_terms),2):
        if isinstance(term1,FreeVar) and isinstance(term2,FreeVar) and term1.name == term2.name:
            column_pairs_with_equal_free_vars.append((i,j))

    if len(column_pairs_with_equal_free_vars) > 0:
        const_select_node = select_node
        # override name so that select node remains the topmost node
        select_node = get_new_node_name(g)
        g.add_node(select_node, op='select',theta=equalColTheta(*column_pairs_with_equal_free_vars))
        g.add_edge(select_node,const_select_node)

    # rename the column name of first appearance of each free var
    first_pos_of_free_var_list = {}
    for i,term in enumerate(combined_terms):
        if isinstance(term,FreeVar) and term.name not in first_pos_of_free_var_list:
            first_pos_of_free_var_list[term.name] = i
    rename_node = get_new_node_name(g)
    g.add_node(rename_node, op='rename',names=[(idx,var_name) for var_name,idx in first_pos_of_free_var_list.items()])
    g.add_edge(rename_node,select_node)

    # project on the free vars to leave out constant or redundant columns
    project_node = get_new_node_name(g)
    g.add_node(project_node, op='project',on=list(first_pos_of_free_var_list.keys()))
    g.add_edge(project_node,rename_node)

    return project_node,project_input_vars


# %% ../nbs/009_term_graphs.ipynb 21
def get_bounding_order(rule:Rule):
    """Get an order of evaluation for the body of a rule
    this is a very naive ordering that can be heavily optimized"""

    # we start with all relations since they can be bound at once
    order = list()
    bounded_vars = set()
    for rel in rule.body:
        if isinstance(rel,Relation):
            order.append(rel)
            for term in rel.terms:
                if isinstance(term,FreeVar):
                    bounded_vars.add(term)

    unordered_ierelations = {rel for rel in rule.body if isinstance(rel,IERelation)}
    while len(unordered_ierelations) > 0:
        for ie_rel in unordered_ierelations:
            in_free_vars = {term for term in ie_rel.in_terms if isinstance(term,FreeVar)}
            if in_free_vars.issubset(bounded_vars):
                order.append(ie_rel)
                out_free_vars = {term for term in ie_rel.out_terms if isinstance(term,FreeVar)}
                bounded_vars = bounded_vars.union(out_free_vars)
                unordered_ierelations.remove(ie_rel)
                break

    return order

# %% ../nbs/009_term_graphs.ipynb 24
def rule_to_graph(rule:Rule,rule_id):
    """
    converts a rule to a graph
    """
    g=nx.DiGraph()
    body_rels = get_bounding_order(rule)

    top_bottom_nodes = []

    # add all body relations to the graph
    for rel in body_rels:
        if isinstance(rel,Relation):
            top,bottom = add_relation(g,rel)
            top_bottom_nodes.append((top,bottom))
        elif isinstance(rel,IERelation):
            top,bottom = add_ie_relation(g,rel)
            top_bottom_nodes.append((top,bottom))

    # connect outputs of different rels via joins
    # and connect input of ie functons into the join
    for i,((top,bottom),rel) in enumerate(zip(top_bottom_nodes,body_rels)):
        logger.debug(f'connecting bodies iteration {i}')
        if i == 0:
            prev_top = top
            continue
        logger.debug(f'connecting {prev_top} to {top}')

        join_node_name = get_new_node_name(g)
        g.add_node(join_node_name, op='join')
        g.add_edge(join_node_name,prev_top)
        g.add_edge(join_node_name,top)

        if isinstance(rel,IERelation):
            ie_has_variable_inputs = any(isinstance(term,FreeVar) for term in rel.in_terms)
            if ie_has_variable_inputs:
                logger.debug(f'adding input of ie {bottom} to join {prev_top}')
                g.add_edge(bottom,prev_top)
        prev_top = join_node_name

    # project all assignments into the head
    head_project_name = get_new_node_name(g)
    g.add_node(head_project_name, op='project', on=[term.name for term in rule.head.terms],rel=f'_{rule.head.name}_{rule_id}')
    g.add_edge(head_project_name,prev_top)

    # add a union for each rule for the given head
    g.add_node(rule.head.name,op='union',rel=rule.head.name)
    g.add_edge(rule.head.name,head_project_name)

    # add rule id for each node
    for u in g.nodes:
        g.nodes[u]['rule_id'] = {rule_id}
    return g


# %% ../nbs/009_term_graphs.ipynb 32
def graph_compose(g1,g2,mapping_dict,debug=False):
    """compose two graphs with a mapping dict"""
    # if there is a node in g2 that is renamed but has a name collision with an existing node that is not renamed, we will rename the existing node to a uniq name
    # making new names into a digraph is a dirty hack, TODO resolve this
    save_new_names= nx.DiGraph()
    original_mapping_dict = mapping_dict.copy()
    for u2 in g2.nodes():
        if u2 not in mapping_dict and u2 in g1.nodes():
            mapping_dict[u2] = get_new_node_name(g2,avoid_names_from=[g1,save_new_names])
            save_new_names.add_node(mapping_dict[u2])
    if debug:
        return mapping_dict
    g2 = nx.relabel_nodes(g2,mapping_dict,copy=True)

    merged_graph = nx.compose(g1,g2)
    for old_name,new_name in original_mapping_dict.items():
        rule_ids1 = g1.nodes[old_name].get('rule_id',set())
        rule_ids2 = g2.nodes[new_name].get('rule_id',set())
        merged_rule_ids = rule_ids1.union(rule_ids2)
        merged_graph.nodes[new_name]['rule_id'] = merged_rule_ids



    return merged_graph


# %% ../nbs/009_term_graphs.ipynb 38
def merge_term_graphs_pair(g1,g2,exclude_props = ['label'],debug=False):
    """merge two term graphs into one term graph
    when talking about term graphs, 2 nodes if their data is identical and all of their children are identical
    but we would also like to merge rules for the same head, so we will also nodes that have the same 'rel' attribute
    """

    def _are_nodes_equal(g1,u1,g2,u2):

        u1_data = g1.nodes[u1]
        u2_data = g2.nodes[u2]
        
        if 'rel' in u1_data and 'rel' in u2_data:
            return u1_data['rel'] == u2_data['rel']


        
        return False
        # TODO this old code tries to merge nodes, but then its hard to remember which belong to which rules so we only merge
        # so we will do this merging per query
        u1_clean_data = {k:v for k,v in u1_data.items() if k not in exclude_props}
        u2_clean_data = {k:v for k,v in u2_data.items() if k not in exclude_props}

        are_equal = u1_clean_data == u2_clean_data and all(v2 in node_mappings for v2 in g2.successors(u2))
        return are_equal
        

    # we will check for each node in g2 if it has a node in g1 which is it's equal.
    # and save that in a mapping
    node_mappings=dict()# g2 node name to g1 node name
    # we use the fact that g2 is going to be acyclic to travers it in postorder
    for u2 in nx.dfs_postorder_nodes(g2):
        for u1 in g1.nodes():
            if _are_nodes_equal(g1,u1,g2,u2):
                node_mappings[u2] = u1
                break



    if debug:
        return node_mappings
    else:
        return graph_compose(g1,g2,node_mappings)



def merge_term_graphs(gs,exclude_props = ['label'],debug=False):
    """merge a list of term graphs into one term graph
    """
    merge = gs[0]
    for g in gs[1:-1]:
        merge = merge_term_graphs_pair(merge,g,exclude_props,debug=False)
    # if debug, we run debug only on the last merge so we can iteratively debug a list of merges
    return merge_term_graphs_pair(merge,gs[-1],exclude_props,debug=debug)

