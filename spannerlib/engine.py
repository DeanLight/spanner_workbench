# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/010_engine.ipynb.

# %% auto 0
__all__ = ['logger', 'op_to_func', 'DB', 'Engine', 'get_rel', 'compute_node']

# %% ../nbs/010_engine.ipynb 3
from abc import ABC, abstractmethod
import pytest
from collections import defaultdict

import pandas as pd
from pathlib import Path
from typing import no_type_check, Set, Sequence, Any,Optional,List,Callable,Dict,Union
from pydantic import BaseModel
import networkx as nx
import itertools
import logging
logger = logging.getLogger(__name__)

from graph_rewrite import draw, draw_match, rewrite, rewrite_iter
from spannerlib.utils import (
    serialize_graph,
    serialize_df_values,
    checkLogs,
    get_new_node_name
    )

from .span import Span,SpanParser
from spannerlib.data_types import (
    Var, 
    FreeVar, 
    RelationDefinition, 
    Relation, 
    IEFunction,
    IERelation, 
    Rule, 
    pretty
)
from spannerlib.ra import (
    _col_names,
    get_const,
    select,
    project,
    rename,
    union,
    intersection,
    difference,
    join,
    product,
    ie_map,
)

from .term_graph import graph_compose, merge_term_graphs_pair,rule_to_graph,add_select_constants



# %% ../nbs/010_engine.ipynb 5
def _pd_drop_row(df,row_vals):
    new_df = df[(df!=row_vals).all(axis=1)]
    return new_df

def _pd_append_row(df,row_vals):
    return pd.concat([df,pd.DataFrame([row_vals],columns=df.columns)])

# %% ../nbs/010_engine.ipynb 7
class DB(dict):
    def __repr__(self):
        key_str=', '.join(self.keys())
        return f'DB({key_str})'

# %% ../nbs/010_engine.ipynb 9
from copy import deepcopy
class Engine():
    def __init__(self,rewrites=None):
        if rewrites is None:
            self.rewrites = []
        self.symbol_table={
            # key : type,val
        }
        self.Relation_defs={
            # key : RelationDefinition for both real and derived relations
        }
        self.ie_functions={
            # name : IEFunction class
        }

        self.term_graph = nx.DiGraph()
        
        self.node_counter = itertools.count()
        self.rule_counter = itertools.count()

        self.db = DB(
            # relation_name: dataframe
        )

        # lets skip this for now and keep it a an attribute in the node graph
        self.rules_to_ids = {
            # rule pretty string, to node id in term_graph
        }

        # self.rels_to_nodes() = {
        #     # relation name to node that represents it
        # }
    

    def set_var(self,var_name,value,read_from_file=False):
        symbol_table = self.symbol_table
        if var_name in symbol_table:
            existing_type,existing_value = symbol_table[var_name]
            if type(value) != existing_type:
                raise ValueError(f"Variable {var_name} was previously defined with {existing_value}({pretty(existing_type)})"
                                f" but is trying to be redefined to {value}({pretty(type(value))}) of a different type which might interfere with previous rule definitions")    
        symbol_table[var_name] = type(value),value
        return
    def get_var(self,var_name):
        return self.symbol_table.get(var_name,None)
    
    def del_var(self,var_name):
        del self.symbol_table[var_name]

    def get_relation(self,rel_name:str):
        return self.Relation_defs.get(rel_name,None)

    def set_relation(self,rel_def:RelationDefinition):
        if rel_def.name in self.Relation_defs:
            existing_def = self.Relation_defs[rel_def.name]
            if existing_def != rel_def:
                raise ValueError(f"Relation {rel_def.name} was previously defined with {existing_def}"
                                f"but is trying to be redefined to {rel_def} which might interfere with previous rule definitions")
        else:
            self.Relation_defs[rel_def.name] = rel_def
            #TODO fix make sure that the empty df has the correct types based on the rel_def
            empty_df = pd.DataFrame(columns=_col_names(len(rel_def.scheme)))
            self.db[rel_def.name] = empty_df
            self.term_graph.add_node(rel_def.name,rel=rel_def.name)

    def del_relation(self,rel_name:str):
        # TODO we need to think about what to do with all relations that used this rule
        raise NotImplementedError("deleting relations is not supported yet")
        return

    def add_fact(self,fact:Relation):
        self.db[fact.name] = _pd_append_row(self.db[fact.name],fact.terms)

    def add_facts(self,rel_name,facts:pd.DataFrame):
        facts= facts.copy()
        facts.columns = _col_names(len(facts.columns))
        self.db[rel_name] = pd.concat([self.db[rel_name],facts])

    def del_fact(self,fact:Relation):
        self.db[fact.name] = _pd_drop_row(df = self.db[fact.name],row_vals=fact.terms)

    def get_ie_function(self,name:str):
        return self.ie_functions.get(name,None)

    def set_ie_function(self,ie_func:IEFunction):
        self.ie_functions[ie_func.name]=ie_func

    def del_ie_function(self,name:str):
        del self.ie_functions[name]

    def add_rule(self,rule:Rule,schema:RelationDefinition=None):
        if not self.get_relation(rule.head.name) and schema is None:
            raise ValueError(f"Relation {rule.head.name} not defined before adding the rule with it's head\n"
                             f"And an relation schema was not supplied."
                             f"existing relations are {self.Relation_defs.keys()}")

        if not schema is None:
            self.set_relation(schema)

        rule_id = next(self.rule_counter)

        self.rules_to_ids[pretty(rule)] = rule_id

        g2 = rule_to_graph(rule,rule_id)

        merge_term_graph = merge_term_graphs_pair(self.term_graph,g2)
        self.term_graph = merge_term_graph
        

    def del_rule(self,rule_str:str):
        if not rule_str in self.rules_to_ids:
            raise ValueError(f"Rule {rule_str} does not exist\n"
                             f"existing rules are {self.rules_to_ids.keys()}")
        rule_id = self.rules_to_ids[rule_str]
        self.rules_to_ids.pop(rule_str)
        g = self.term_graph
        nodes_to_delete=[]
        for u in g.nodes:
            node_rule_ids = g.nodes[u].get('rule_id',set())
            if rule_id in node_rule_ids:
                node_rule_ids.remove(rule_id)
                if len(node_rule_ids) == 0:
                    nodes_to_delete.append(u)
        g.remove_nodes_from(nodes_to_delete)
            
        return

    def _inline_db_and_ies_in_graph(self,g:nx.DiGraph):
        g=deepcopy(g)
        for u in g.nodes:
            if g.out_degree(u)==0 and 'rel' in g.nodes[u]:
                g.nodes[u]['op'] = 'get_rel'
                g.nodes[u]['db'] = self.db
            elif g.nodes[u]['op'] == 'ie_map':
                ie_func_name = g.nodes[u]['func']
                ie_definition = self.ie_functions[ie_func_name]
                g.nodes[u]['func'] = ie_definition.func
                g.nodes[u]['name'] = ie_definition.name
                g.nodes[u]['in_schema'] = ie_definition.in_schema
                g.nodes[u]['out_schema'] = ie_definition.out_schema
        return g


    def plan_query(self,q_rel:Relation,rewrites=None):
        if rewrites is None:
            rewrites = self.rewrites
        query_graph = self._inline_db_and_ies_in_graph(self.term_graph)

        # get the sub term graph induced by the relation head
        root_node = q_rel.name
        connected_nodes = list(nx.shortest_path(query_graph,root_node).keys())
        query_graph = nx.DiGraph(nx.subgraph(query_graph,connected_nodes))
        
        # based on the asked relation, add:
        # select node if there are constants
        # project node to project to the remaining free variables
        # rename node to rename the cols to the Free vars the query is asking for
        select_node = add_select_constants(query_graph,root_node,q_rel.terms)
        rename_node = get_new_node_name(query_graph)
        query_graph.add_node(rename_node, op='rename',names=[(i,term.name) for i,term in enumerate(q_rel.terms) if isinstance(term,FreeVar)])
        query_graph.add_edge(rename_node,select_node)
        project_node = get_new_node_name(query_graph)
        query_graph.add_node(project_node, op='project', on=[term.name for term in q_rel.terms if isinstance(term,FreeVar)])
        query_graph.add_edge(project_node,rename_node)

        # TODO for all rewrites, run them
        return query_graph,project_node

    def execute_plan(self,query_graph,root_node,return_intermediate=False):
        results_dict = defaultdict(list)
        results = compute_node(query_graph,root_node,results_dict)
        if return_intermediate:
            return results,results_dict
        else:
            return results

    def run_query(self,q:Relation,rewrites=None,return_intermediate=False):
        query_graph,root_node = self.plan_query(q,rewrites)
        return self.execute_plan(query_graph,root_node,return_intermediate=return_intermediate)


# %% ../nbs/010_engine.ipynb 26
def get_rel(rel,db,**kwargs):
    # helper function to get the relation from the db for external relations
    return db[rel]

op_to_func = {
    'union':union,
    'intersection':intersection,
    'difference':difference,
    'select':select,
    'project':project,
    'rename':rename,
    'join':join,
    'ie_map':ie_map,
    'get_rel':get_rel,
    'get_const':get_const,
    'product':product,
}

# %% ../nbs/010_engine.ipynb 27
def compute_node(G,u,results_dict):
    """
    """
    global op_to_func
    u_data = G.nodes[u]
    if u_data.get('final',False):
        return results_dict[u][-1]
    

    children_ids = list(G.successors(u))
    children_data = [G.nodes[child_id] for child_id in children_ids]

    if len(children_ids)==0:
        all_children_final=True
        children_results=[]
        
    else:
        # this block helps avoid infinite recursion when we need to initialize the 0th iteration of a node in a cycle as the empty relation
        if u_data.get('visited',False):
            u_data['visited'] = True
            results_dict[u].append(pd.DataFrame())
            return pd.DataFrame()
        u_data['visited'] =True
        
        children_results = [compute_node(G,child_id,results_dict) for child_id in children_ids]
        all_children_final = all(child_data.get('final',False) for child_data in children_data)




    op_code = u_data['op']
    op_func = op_to_func[op_code]
    logger.debug(f'computing node {u} with op {op_code} and children results {children_results} and data {u_data}')
    current_results = op_func(*children_results,**u_data)
    results_iter = len(results_dict[u])
    logger.debug(f'node {u} results after iteration {results_iter} are {current_results}')
    results_dict[u].append(current_results)

    # if all children are final then we can mark this node as final
    if all_children_final:
        logger.debug(f'setting node {u} as final since all children are final')
        u_data['final'] = True
    # else check for fixed point
    elif len(results_dict[u])>1:
        this_res = results_dict[u][-1]
        last_res = results_dict[u][-2]
        if pd.DataFrame.equals(this_res,last_res):
            logger.debug(f'setting node {u} as final since we reached a fixed point')
            u_data['final'] = True
        else:
            u_data['final'] = False
    # if this is the first iteration we need to wait for the second one to check for fixed point so final is still false
    else:
        u_data['final']=False

    return current_results




